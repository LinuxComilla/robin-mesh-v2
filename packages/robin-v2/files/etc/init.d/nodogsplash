#!/bin/sh /etc/rc.common

<<COPYRIGHT

Copyright (C) 2010 Antonio Anselmi <tony.anselmi@gmail.com>

This program is free software; you can redistribute it and/or
modify it under the terms of version 2 of the GNU General Public
License as published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this file.  If not, see <http://www.gnu.org/licenses/>.

COPYRIGHT

START=78
STOP=78

IPT=/usr/sbin/iptables
WD_DIR=/usr/bin
OPTIONS=""

test_module() {
	### Test ipt_mark with iptables
	test_ipt_mark () {
	IPTABLES_OK=$($IPT -A FORWARD -m mark --mark 2 -j ACCEPT 2>&1 | grep "No chain.target.match")
	if [ -z "$IPTABLES_OK" ]; then
		$IPT -D FORWARD -m mark --mark 2 -j ACCEPT 2>&1
		echo 1
		else
		echo 0
	fi
    }

	### Test ipt_mac with iptables
	test_ipt_mac () {
	IPTABLES_OK=$($IPT -A INPUT -m mac --mac-source 00:00:00:00:00:00 -j ACCEPT 2>&1 | grep "No chain.target.match")
	if [ -z "$IPTABLES_OK" ]; then
		$IPT -D INPUT -m mac --mac-source 00:00:00:00:00:00 -j ACCEPT 2>&1
		echo 1
		else
		echo 0
	fi
	}

	### Test ipt_REDIRECT with iptables
	test_ipt_REDIRECT () {
	IPTABLES_OK=$($IPT -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 2060 2>&1 | grep "No chain.target.match")
	if [ -z "$IPTABLES_OK" ]; then
		$IPT -t nat -D PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 2060 2>&1
		echo 1
		else
		echo 0
	fi
	}

	### Find a module on disk
	module_exists () {
	echo " Looking for a module on disk"
	EXIST=$(find /lib/modules/`uname -r` -name $1.*o 2>/dev/null)
	if [ -n "$EXIST" ]; then
		echo 1
		else
		echo 0
	fi
	}

	### Test if a module is in memory
	module_in_memory () {
	MODULE=$(lsmod | grep $1 | awk '{print $1}')
	if [ "$MODULE" = "$1" ]; then
		echo 1
		else
		echo 0
	fi
	}

	echo "Testing for iptables modules"

	echo "  Testing ipt_mac"
	TEST_IPT_MAC=$(test_ipt_mac)
	if [ "$TEST_IPT_MAC" = "0" ]; then
		echo "   iptables is not working with ipt_mac"
		echo "   Scanning disk for ipt_mac module"
		TEST_IPT_MAC_MODULE_EXISTS=$(module_exists "ipt_mac")
		if [ "$TEST_IPT_MAC_MODULE_EXISTS" = "0" ]; then
			echo "   ipt_mac module is missing, please install it (kernel or module)"
			exit
			else
			echo "   ipt_mac module exists, trying to load"
			insmod ipt_mac > /dev/null
			TEST_IPT_MAC_MODULE_MEMORY=$(module_in_memory "ipt_mac")
			if [ "$TEST_IPT_MAC_MODULE_MEMORY" = "0" ]; then
				echo "  Error: ipt_mac not loaded"
				exit
				else
				echo "  ipt_mac loaded sucessfully"
			fi
		fi

	else
		echo "   ipt_mac  module is working"
	fi

	echo "  Testing ipt_mark"
	TEST_IPT_MARK=$(test_ipt_mark)
	if [ "$TEST_IPT_MARK" = "0" ]; then
		echo "   iptables is not working with ipt_mark"
		echo "   Scanning disk for ipt_mark module"
		TEST_IPT_MARK_MODULE_EXISTS=$(module_exists "ipt_mark")
		if [ "$TEST_IPT_MARK_MODULE_EXISTS" = "0" ]; then
			echo "   iptables ipt_mark module missing, please install it (kernel or module)"
			exit
			else
			echo "   ipt_mark module exists, trying to load"
			insmod ipt_mark
			TEST_IPT_MARK_MODULE_MEMORY=$(module_in_memory "ipt_mark")
			if [ "$TEST_IPT_MARK_MODULE_MEMORY" = "0" ]; then
				echo "   Error: ipt_mark not loaded"
				exit
				else
				echo "   ipt_mark loaded sucessfully"
			fi
		fi

	else
		echo "   ipt_mark module is working"
	fi

	echo "  Testing ipt_REDIRECT"
	TEST_IPT_MAC=$(test_ipt_REDIRECT)
	if [ "$TEST_IPT_MAC" = "0" ]; then
		echo "   iptables is not working with ipt_REDIRECT"
		echo "   Scanning disk for ipt_REDIRECT module"
		TEST_IPT_MAC_MODULE_EXISTS=$(module_exists "ipt_REDIRECT")
		if [ "$TEST_IPT_MAC_MODULE_EXISTS" = "0" ]; then
			echo "   ipt_REDIRECT module is missing, please install it (kernel or module)"
			exit
			else
			echo "   ipt_REDIRECT module exists, trying to load"
			insmod ipt_REDIRECT > /dev/null
			TEST_IPT_MAC_MODULE_MEMORY=$(module_in_memory "ipt_REDIRECT")
			if [ "$TEST_IPT_MAC_MODULE_MEMORY" = "0" ]; then
				echo "  Error: ipt_REDIRECT not loaded"
				exit
				else
				echo "  ipt_REDIRECT loaded sucessfully"
			fi
		fi

	else
	echo "   ipt_REDIRECT  module is working"
	fi
}

start() {
	echo "Starting nodogsplash ... "
	if $WD_DIR/ndsctl status 2> /dev/null ; then
		echo "FAILED:  nodogsplash already running"
		else
		test_module
		if $WD_DIR/nodogsplash $OPTIONS ; then
			echo "OK: nodogsplash started"

			# set a ceiling on the number of active threads to prevent
			# overloads.  16 is still quite high, but safe.
			uci set cp_switch.handler_1.max_threads=16
			uci commit cp_switch
			
			#hack ndsNET chain in case of no_AP1_ISOLATION
			if [ "$(uci get iprules.filter.AP1_isolation)" -eq 0 ]; then
				T=0 
				while [ -z "$(iptables -n -L -v |grep ndsNET)" ]; do
					T=$((T + 1 ))
					[ "$T" -gt 6 ] && break	#exit anyway
					sleep 10
				done				
				POSITION=$(iptables -n -L ndsNET |grep -v 'Chain' |grep -v 'target' |wc -l)
				iptables -I ndsNET $POSITION -o ath0 -d 5.0.0.0/8 -j ACCEPT
				iptables -I ndsNET $POSITION -o ath0 -d 101.0.0.0/8 -j ACCEPT
			fi

			else
			echo "FAILED:  nodogsplash exited with non 0 status"
		fi
	fi
}

stop() {
	echo "Stopping nodogsplash ... "
	if $WD_DIR/ndsctl status 2> /dev/null ;  then
		if $WD_DIR/ndsctl stop ; then
			echo "OK: nodogsplash stopped"
			else
			echo "FAILED:  ndsctl stop exited with non 0 status"
		fi
      
		else
		echo "FAILED:  nodogsplash was not running"
	fi
}

status() {
	$WD_DIR/ndsctl status
}

EXTRA_COMMANDS="status"
#
